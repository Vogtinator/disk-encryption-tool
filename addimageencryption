#!/bin/bash
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: Copyright 2023 SUSE LLC
set -e
shopt -s nullglob

unset "${!LC_*}"
LANG="C.utf8"
export LANG

# set to --keep-title to use altenate screen. Better for debugging but causes flicker
dialog_altenate_screen=
dialog_backtitle="Image Encryption Tool"
interactive=
verbose=
nl=$'\n'

crdev=
loopdev=
mp=
tmpdir=$(mktemp -d -t sdboot.XXXXXX)
cleanup()
{
	if [ -n "$mp" ]; then
		for i in proc dev sys .snapshots boot/efi var; do
			mountpoint -q "$mp/$i" || continue
			umount "$mp/$i"
		done
		umount "$mp"
	fi
	[ -z "$crdev" ] || cryptsetup close "${crdev##*/}"
	if [ -n "$loopdev" ]; then
		if [ "${loopdev#/dev/nbd}" != "$loopdev" ]; then
			qemu-nbd -f qcow2 -d "$loopdev"
		else
			losetup -d "$loopdev"
		fi
	fi
	rm -rf "$tmpdir"
}
trap cleanup EXIT

tmpfile="$tmpdir/tmp"

helpandquit()
{
	cat <<-EOF
		Usage: $0 [OPTIONS] IMAGE

		Encrypt IMAGE

		OPTIONS:
		  --verbose  verbose
		  -h         help screen

	EOF
	exit 0
}

log_info()
{
	[ "${verbose:-0}" -gt 0 ] || return 0
	echo "$@"
}

d(){
	local retval=0
	# Bash makes it a bit annoying to read the output of a different FD into a variable, it
	# only supports reading stdout by itself. So redirect 3 to stdout and 1 to the real stdout.
	exec {stdoutfd}>&1
	result="$(dialog $dialog_altenate_screen --backtitle "$dialog_backtitle" --output-fd 3 "$@" 3>&1 1>&${stdoutfd})" || retval=$?
	# Word splitting makes it necessary to use eval here.
	eval "exec ${stdoutfd}>&-"
	return "$retval"
}

err()
{
	if [ "$interactive" = 1 ]; then
		d --title 'Error' --ok-label "Quit" --colors --aspect 60 --msgbox "\Z1Error:\Zn $*" 0 0
	else
		echo "Error: $*" >&2
	fi
	exit 1
}

warn()
{
	if [ "$interactive" = 1 ]; then
		d --title 'Warning' --ok-label "Continue" --colors --aspect 60 --msgbox "\Z1Warning:\Zn $*" 0 0
	else
		echo "Warning: $*" >&2
	fi
	exit 1
}

# Given the number of total item pairs, outputs the number of items to display at once
menuheight() {
	local height=$(($1 / 2))
	[ "$height" -le "$dh_menu" ] || height="$dh_menu"
	echo "$height"
}

stty_size() {
	set -- $(stty size 2>/dev/null)
	LINES="$1"
	COLUMNS="$2"
	# stty size can return zero when not ready or
	# its a serial console
	if [ "$COLUMNS" = "0" ] || [ "$LINES" = "0" ]; then
		LINES=24
		COLUMNS=80
	fi

	dh_menu=$((LINES-15))
	dh_text=$((LINES-5))
}

fakereencrypt()
{
	while read -r line; do
		read -r bytes size < <(echo "$line" | jq -r '[.device_bytes, .device_size]|join(" ")')
		echo "$((bytes*100/size))"
		usleep 500
	done < p
}

isdigits()
{
	local v="${1:?}"
	[ -z "${v//[0-9]*/}" ]
}

report_progress()
{
	local bytes size
	while read -r bytes size; do
		isdigits "$bytes" || continue
		isdigits "$size" || continue
		printf "\rEncrypting... %d%%" "$((bytes*100/size))"
	done
}

dialog_password()
{
	[ -z "$password" ] || return 0
        while true; do
                d --insecure --passwordbox  $"Enter encryption password" 0 0
                password="$result"
                d --insecure --passwordbox  $"Confirm encryption password" 0 0
                if [ "$password" != "$result" ]; then
                        d --msgbox $"Entered passwords don't match" 5 40
                        continue
                fi
                [ -n "$password" ] || err "No password, no encryption"
                break
        done
}

####### main #######

stty_size

getopttmp=$(getopt -o hc:v --long help,verbose,flicker -n "${0##*/}" -- "$@")
eval set -- "$getopttmp"

while true ; do
        case "$1" in
                -h|--help) helpandquit ;;
		-v|--verbose) verbose=$((++verbose)); shift ;;
		--flicker) dialog_altenate_screen=--keep-tite; shift ;;
                --) shift ; break ;;
                *) echo "Internal error!" ; exit 1 ;;
        esac
done

[ -n "$1" ] || helpandquit

image="$1"
shift

case "${image##*/}" in
	SLE-Micro.x86_64-5.*-Default-GM.raw ) ;;
	openSUSE-MicroOS.x86_64-*-kvm-and-xen*.qcow2) ;;
	*) err "Unsupported image" ;;
esac

if [ "${image%.qcow2}" = "$image" ]; then
	log_info "setting up loop device"
	loopdev="$(losetup --show -fP "$image")"
	log_info "loop device $loopdev"
else
	[ -e "/dev/nbd0" ] || modprobe nbd
	loopdev=/dev/nbd0
	qemu-nbd -c "$loopdev" "$image"
fi
looppart="${loopdev}p3"

eval "$(blkid -c /dev/null -o export "$looppart"|sed 's/^/loop_/')"

[ "$loop_TYPE" != crypto_LUKS ] || err "Already encrypted"
[ "$loop_TYPE" = btrfs ] || err "File system is $loop_TYPE but only btrfs is supported"

dialog_password

log_info "mounting fs"
mkdir -p "$tmpdir/mnt"
mount -t btrfs -o rw "${looppart}" "$tmpdir/mnt"
mp="$tmpdir/mnt"

read -r minsize bytes _rest < <(btrfs inspect-internal min-dev-size "$mp")
isdigits "$minsize" || err "Failed to read minimum btrfs size"
[ "$bytes" = 'bytes' ] || err "Failed to read minimum btrfs size"

log_info "resizing fs"
btrfs filesystem resize "$minsize" "$mp"
umount "$mp"
unset mp

# shrink partition to a minimum so reencryption doesn't write everything
log_info "resizing partition"
echo "size=$((minsize/1024+32*1024))KiB" | sfdisk -N 3 "$loopdev"

echo -n "Encrypting..."
echo "$password" | cryptsetup reencrypt -q \
	--encrypt \
	--type luks1 \
	--reduce-device-size 32m \
	--force-password \
	--progress-json --progress-frequency=1 \
	--iter-time 2000 \
	"${looppart}" | \
		sed -u -e 's/.*device_bytes":"\([0-9]*\).*device_size":"\([0-9]*\).*/\1 \2/' | \
		report_progress
echo

log_info "Encryption done"

log_info "grow partition again"
echo "size=+" | sfdisk -N 3 "$loopdev"

log_info "open encrypted image"
echo "$password" | cryptsetup open "${looppart}" cr_root
crdev="/dev/mapper/cr_root"
mount -o rw "$crdev" "$tmpdir/mnt"
mp="$tmpdir/mnt"

log_info "resizing fs to max again"
btrfs filesystem resize max "$mp"

log_info "switch to rw"
btrfs prop set -t s "$mp" ro false

eval "$(blkid -c /dev/null -o export "$looppart"|sed 's/^/loop_/')"
echo cr_root "/dev/disk/by-uuid/$loop_UUID" none x-initrd.attach > "$mp"/etc/crypttab
echo GRUB_ENABLE_CRYPTODISK=y >> "$mp"/etc/default/grub

for i in proc dev sys; do
	mount --bind "/$i" "$mp/$i"
done

for i in /.snapshots /boot/efi /var; do
	chroot "$mp" mount "$i"
done

log_info "Update bootloader"
sed -i -e 's/^LOADER_TYPE=.*/LOADER_TYPE="grub2"/' "$mp"/etc/sysconfig/bootloader
chroot "$mp" update-bootloader --reinit
sed -i -e 's/^LOADER_TYPE=.*/LOADER_TYPE="grub2-efi"/' "$mp"/etc/sysconfig/bootloader
chroot "$mp" update-bootloader --reinit
mv "$mp/boot/grub2/grub.cfg" "$mp/boot/grub2/grub.cfg.bak"
cat > "$mp/boot/grub2/grub.cfg" <<'EOF'
set linux=linux
set initrd=initrd
if [ "${grub_cpu}" = "x86_64" -o "${grub_cpu}" = "i386" ]; then
    if [ "${grub_platform}" = "efi" ]; then
        set linux=linuxefi
        set initrd=initrdefi
    fi
fi
export linux initrd
EOF
sed -e 's/linuxefi/$linux/;s/initrdefi/$initrd/' < "$mp/boot/grub2/grub.cfg.bak" >> "$mp/boot/grub2/grub.cfg"
rm "$mp/boot/grub2/grub.cfg.bak"

initrd="$(readlink "$mp/boot/initrd")"
kv="${initrd#initrd-}"
chroot "$mp" dracut -f "/boot/$initrd" "$kv"

log_info "set ro again"
btrfs prop set -t s "$mp" ro true

echo "Image encryption completed"
