#!/bin/bash
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: Copyright 2023 SUSE LLC
set -e
shopt -s nullglob

unset "${!LC_*}"
LANG="C.utf8"
export LANG

verbose=
nl=$'\n'

crdev=
loopdev=
mp=
tmpdir=$(mktemp -d -t sdboot.XXXXXX)
cleanup()
{
	if [ -n "$mp" ]; then
		for i in proc dev sys .snapshots boot/efi var; do
			mountpoint -q "$mp/$i" || continue
			umount "$mp/$i"
		done
		umount "$mp"
	fi
	[ -z "$crdev" ] || cryptsetup close "${crdev##*/}"
	if [ -n "$loopdev" ]; then
		if [ "${loopdev#/dev/nbd}" != "$loopdev" ]; then
			qemu-nbd -f qcow2 -d "$loopdev"
		else
			losetup -d "$loopdev"
		fi
	fi
	rm -rf "$tmpdir"
}
trap cleanup EXIT

helpandquit()
{
	cat <<-EOF
		Usage: $0 [OPTIONS] IMAGE

		Encrypt IMAGE

		OPTIONS:
		  --verbose  verbose
		  -h         help screen

	EOF
	exit 0
}

log_info()
{
	[ "${verbose:-0}" -gt 0 ] || return 0
	echo "$@"
}

err()
{
	echo "Error: $*" >&2
	exit 1
}

warn()
{
	echo "Warning: $*" >&2
	exit 1
}

isdigits()
{
       local v="${1:?}"
       [ -z "${v//[0-9]*/}" ]
}

read_password()
{
	local password2
	[ -z "$password" ] || return 0
        while true; do
                read -r -s -p "Enter encryption passphrase: " password
		echo
		if type -p pwscore &>/dev/null; then
			echo "$password" | pwscore || continue
		fi
                read -r -s -p "Confirm encryption passphrase: " password2
		echo
                if [ "$password" != "$password2" ]; then
                        echo "Entered passwords don't match"
                        continue
                fi
                [ -n "$password" ] || err "No password, no encryption"
                break
        done
}

encrypt()
{
	if type -p cryptsetup-reencrypt &> /dev/null; then
		echo "$password" | cryptsetup-reencrypt --new "$@"
	else
		echo "$password" | cryptsetup reencrypt --encrypt "$@"
	fi
}

####### main #######

getopttmp=$(getopt -o hc:v --long help,verbose -n "${0##*/}" -- "$@")
eval set -- "$getopttmp"

while true ; do
        case "$1" in
                -h|--help) helpandquit ;;
		-v|--verbose) verbose=$((++verbose)); shift ;;
                --) shift ; break ;;
                *) echo "Internal error!" ; exit 1 ;;
        esac
done

[ -n "$1" ] || helpandquit

image="$1"
shift

case "${image##*/}" in
	SLE-Micro.x86_64-5.*-Default-GM.raw ) ;;
	openSUSE-MicroOS.x86_64-*-kvm-and-xen*.qcow2) ;;
	*) err "Unsupported image" ;;
esac

if [ "${image%.qcow2}" = "$image" ]; then
	log_info "setting up loop device"
	loopdev="$(losetup --show -fP "$image")"
	log_info "loop device $loopdev"
else
	[ -e "/dev/nbd0" ] || modprobe nbd
	loopdev=/dev/nbd0
	qemu-nbd -c "$loopdev" "$image"
	udevadm settle
fi
looppart="${loopdev}p3"

eval "$(blkid -c /dev/null -o export "$looppart"|sed 's/^/loop_/')"

[ "$loop_TYPE" != crypto_LUKS ] || err "Already encrypted"
[ "$loop_TYPE" = btrfs ] || err "File system is $loop_TYPE but only btrfs is supported"

read_password

log_info "mounting fs"
mkdir -p "$tmpdir/mnt"
mount -t btrfs -o rw "${looppart}" "$tmpdir/mnt"
mp="$tmpdir/mnt"

read -r minsize bytes _rest < <(btrfs inspect-internal min-dev-size "$mp")
isdigits "$minsize" || err "Failed to read minimum btrfs size"
[ "$bytes" = 'bytes' ] || err "Failed to read minimum btrfs size"

log_info "resizing fs"
btrfs filesystem resize "$minsize" "$mp"
umount "$mp"
unset mp

# shrink partition to a minimum so reencryption doesn't write everything
log_info "resizing partition"
echo "size=$((minsize/1024+32*1024))KiB" | sfdisk -N 3 "$loopdev"

echo "Encrypting..."
encrypt \
	--type luks1 \
	--reduce-device-size 32m \
	--progress-frequency=1 \
	--iter-time 2000 \
	"${looppart}"

log_info "Encryption done"

log_info "grow partition again"
echo ", +" | sfdisk -N 3 "$loopdev"

log_info "open encrypted image"
echo "$password" | cryptsetup open "${looppart}" cr_root
crdev="/dev/mapper/cr_root"
mount -o rw "$crdev" "$tmpdir/mnt"
mp="$tmpdir/mnt"

log_info "resizing fs to max again"
btrfs filesystem resize max "$mp"

log_info "switch to rw"
btrfs prop set -t s "$mp" ro false

eval "$(blkid -c /dev/null -o export "$looppart"|sed 's/^/loop_/')"
echo cr_root "/dev/disk/by-uuid/$loop_UUID" none x-initrd.attach > "$mp"/etc/crypttab
echo GRUB_ENABLE_CRYPTODISK=y >> "$mp"/etc/default/grub

for i in proc dev sys; do
	mount --bind "/$i" "$mp/$i"
done

for i in /.snapshots /boot/efi /var; do
	chroot "$mp" mount "$i"
done

log_info "Update bootloader"
sed -i -e 's/^LOADER_TYPE=.*/LOADER_TYPE="grub2"/' "$mp"/etc/sysconfig/bootloader
chroot "$mp" update-bootloader --reinit
sed -i -e 's/^LOADER_TYPE=.*/LOADER_TYPE="grub2-efi"/' "$mp"/etc/sysconfig/bootloader
chroot "$mp" update-bootloader --reinit
mv "$mp/boot/grub2/grub.cfg" "$mp/boot/grub2/grub.cfg.bak"
cat > "$mp/boot/grub2/grub.cfg" <<'EOF'
set linux=linux
set initrd=initrd
if [ "${grub_cpu}" = "x86_64" -o "${grub_cpu}" = "i386" ]; then
    if [ "${grub_platform}" = "efi" ]; then
        set linux=linuxefi
        set initrd=initrdefi
    fi
fi
export linux initrd
EOF
sed -e 's/linuxefi/$linux/;s/initrdefi/$initrd/' < "$mp/boot/grub2/grub.cfg.bak" >> "$mp/boot/grub2/grub.cfg"
rm "$mp/boot/grub2/grub.cfg.bak"

initrd="$(readlink "$mp/boot/initrd")"
kv="${initrd#initrd-}"
chroot "$mp" dracut -f "/boot/$initrd" "$kv"

log_info "set ro again"
btrfs prop set -t s "$mp" ro true

echo "Image encryption completed"
