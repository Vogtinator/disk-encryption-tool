#!/bin/bash
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: Copyright 2023 SUSE LLC
set -e
shopt -s nullglob

# set to --keep-title to use altenate screen. Better for debugging but causes flicker
dialog_altenate_screen=
dialog_backtitle="Image Encryption Tool"
interactive=
verbose=
nl=$'\n'

crdev=
loopdev=
mp=
tmpdir=$(mktemp -d -t sdboot.XXXXXX)
cleanup()
{
	if [ -n "$mp" ]; then
		for i in proc dev sys .snapshots boot/efi var; do
			mountpoint -q "$mp/$i" || continue
			umount "$mp/$i"
		done
		umount "$mp"
	fi
	[ -z "$crdev" ] || cryptsetup close "${crdev##*/}"
	[ -z "$loopdev" ] || losetup -d "$loopdev"
	rm -rf "$tmpdir"
}
trap cleanup EXIT

tmpfile="$tmpdir/tmp"

helpandquit()
{
	cat <<-EOF
		Usage: $0 [OPTIONS] IMAGE

		Encrypt IMAGE

		OPTIONS:
		  --verbose  verbose
		  -h         help screen

	EOF
	exit 0
}

log_info()
{
	[ "${verbose:-0}" -gt 0 ] || return 0
	echo "$@"
}

d(){
	local retval=0
	# Bash makes it a bit annoying to read the output of a different FD into a variable, it
	# only supports reading stdout by itself. So redirect 3 to stdout and 1 to the real stdout.
	exec {stdoutfd}>&1
	result="$(dialog $dialog_altenate_screen --backtitle "$dialog_backtitle" --output-fd 3 "$@" 3>&1 1>&${stdoutfd})" || retval=$?
	# Word splitting makes it necessary to use eval here.
	eval "exec ${stdoutfd}>&-"
	return "$retval"
}

err()
{
	if [ "$interactive" = 1 ]; then
		d --title 'Error' --ok-label "Quit" --colors --aspect 60 --msgbox "\Z1Error:\Zn $*" 0 0
	else
		echo "Error: $*" >&2
	fi
	exit 1
}

warn()
{
	if [ "$interactive" = 1 ]; then
		d --title 'Warning' --ok-label "Continue" --colors --aspect 60 --msgbox "\Z1Warning:\Zn $*" 0 0
	else
		echo "Warning: $*" >&2
	fi
	exit 1
}

# Given the number of total item pairs, outputs the number of items to display at once
menuheight() {
	local height=$(($1 / 2))
	[ "$height" -le "$dh_menu" ] || height="$dh_menu"
	echo "$height"
}

stty_size() {
	set -- $(stty size 2>/dev/null)
	LINES="$1"
	COLUMNS="$2"
	# stty size can return zero when not ready or
	# its a serial console
	if [ "$COLUMNS" = "0" ] || [ "$LINES" = "0" ]; then
		LINES=24
		COLUMNS=80
	fi

	dh_menu=$((LINES-15))
	dh_text=$((LINES-5))
}

fakereencrypt()
{
	while read -r line; do
		read -r bytes size < <(echo "$line" | jq -r '[.device_bytes, .device_size]|join(" ")')
		echo "$((bytes*100/size))"
		usleep 500
	done < p
}

calc_progress()
{
	local bytes size
	while read -r bytes size; do
		[ -z "${bytes//[0-9]*/}" ] || continue
		[ -z "${size//[0-9]*/}" ] || continue
		echo "$((bytes*100/size))"
	done
}

dialog_password()
{
	[ -z "$password" ] || return 0
        while true; do
                d --insecure --passwordbox  $"Enter encryption password" 0 0
                password="$result"
                d --insecure --passwordbox  $"Confirm encryption password" 0 0
                if [ "$password" != "$result" ]; then
                        d --msgbox $"Entered passwords don't match" 5 40
                        continue
                fi
                [ -n "$password" ] || err "No password, no encryption"
                break
        done
}

####### main #######

stty_size

getopttmp=$(getopt -o hc:v --long help,verbose,flicker -n "${0##*/}" -- "$@")
eval set -- "$getopttmp"

while true ; do
        case "$1" in
                -h|--help) helpandquit ;;
		-v|--verbose) verbose=$((++verbose)); shift ;;
		--flicker) dialog_altenate_screen=--keep-tite; shift ;;
                --) shift ; break ;;
                *) echo "Internal error!" ; exit 1 ;;
        esac
done

[ -n "$1" ] || helpandquit

case "$1" in
	*/SLE-Micro.x86_64-5.*-Default-GM.raw ) ;;
	*) err "Unsupported image" ;;
esac

image="$1"
shift

dialog_password

log_info "setting up loop device"
loopdev="$(losetup --show -fP "$image")"
looppart="${loopdev}p3"
log_info "loop device $loopdev"

log_info "mounting fs"
mkdir -p "$tmpdir/mnt"
mount -t btrfs -o rw "${looppart}" "$tmpdir/mnt"
mp="$tmpdir/mnt"

log_info "resizing fs"
btrfs filesystem resize -64M "$mp"
umount "$mp"
unset mp

log_info "Encrypting..."
echo "$password" | cryptsetup reencrypt -q \
	--encrypt \
	--type luks1 \
	--reduce-device-size 32m \
	--force-password \
	--progress-json --progress-frequency=1 \
	--iter-time 2000 \
	"${looppart}" | \
		sed -u -e 's/.*device_bytes":"\([0-9]*\).*device_size":"\([0-9]*\).*/\1 \2/' | \
		calc_progress | \
		d --gauge "Encrypting..." 0 0

log_info "Encryption done"
d --infobox "Encryption done" 0 0

log_info "open encrypted image"
echo "$password" | cryptsetup open "${looppart}" cr_root
crdev="/dev/mapper/cr_root"
mount -o rw "$crdev" "$tmpdir/mnt"
mp="$tmpdir/mnt"

btrfs prop set -t s "$mp" ro false

uuid="$(blkid -o export "$looppart"|sed -ne 's/^UUID=//p')"
echo cr_root /dev/disk/by-uuid/$uuid none x-initrd.attach > "$mp"/etc/crypttab
echo GRUB_ENABLE_CRYPTODISK=y >> "$mp"/etc/default/grub

for i in proc dev sys; do
	mount --bind "/$i" "$mp/$i"
done

for i in /.snapshots /boot/efi /var; do
	chroot "$mp" mount "$i"
done

log_info "Update bootloader"
# XXX: do for legacy and uefi?
chroot "$mp" update-bootloader --reinit

initrd="$(readlink "$mp/boot/initrd")"
kv="${initrd#initrd-}"
chroot "$mp" dracut -f "/boot/$initrd" "$kv"

btrfs prop set -t s "$mp" ro true

log_info "done"
